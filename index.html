<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Genetic Privacy Laws in the US</title>
  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet" type="text/css">
  <style>
    body,
    html {
      height: 100%;
      margin: 0;
      font-family: 'Montserrat', sans-serif;
    }

    #map {
      height: 100vh;
      width: calc(100vw - 350px);
      position: absolute;
      right: 0;
      top: 0;
      overflow: hidden;
    }

    .sidebar {
      width: 350px;
      height: calc(100vh - 190px);
      position: absolute;
      left: 0;
      top: 0;
      background: white;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      transition: width 0.3s ease;
      overflow: auto;
    }

    .sidebar-header {
      padding: 15px 0 15px 15px;
      background: #007BFF;
      color: white;
      text-align: left;
      font-size: 18px;
      font-weight: bold;
    }

    p {
      padding: 0 15px;
      font-size: 14px;
    }

    .layer-control {
      margin-top: 20px;
      padding-left: 15px;
    }

    .layer-control input {
      margin-right: 5px;
    }

    .layer-control button {
      margin: 10px;
      padding: 5px 10px;
      background-color: white;
      color: black;
      box-shadow: 2px 0 3px rgba(0, 0, 0, 0.5);
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .layer-control button:hover {
      background-color: #f0f0f0; /* very light gray */
    }

    .checkbox-group {
      padding-left: 20px;
      margin-bottom: 10px;
    }

    .tooltip {
      position: absolute;
      text-align: left;
      padding: 5px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border: 1px solid #ccc;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
    }

    .highlighted {
      stroke: yellow;
      stroke-width: 2px;
    }
  </style>
</head>

<body>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">Genetic Privacy Laws in the USA</div>
    <div class="sidebar-content">
      <p>To filter the map, select your desired combination of genetic privacy regulations and press the filter button. Press the reset button to return to the general coverage map.</p>
      <h4 style="padding: 0 15px;">Filter by Regulation Type:</h4>
      <div class="layer-control">
        <div>
            <input type="radio" id="lifeLayerToggle" name="layer" value="life">
            <label for="lifeLayerToggle">Life</label>
            <div id="lifeLayerOptions" class="checkbox-group" style="display: none;">
                <input type="checkbox" id="lifeOption1" name="lifeOptions" value="1">
                <label for="lifeOption1">Requires informed consent</label><br>
                <input type="checkbox" id="lifeOption2" name="lifeOptions" value="2">
                <label for="lifeOption2">Prohibits use of genetic info</label><br>
                <input type="checkbox" id="lifeOption3" name="lifeOptions" value="3">
                <label for="lifeOption3">Allowed if actuarially justified</label><br>
                <input type="checkbox" id="lifeOption4" name="lifeOptions" value="4">
                <label for="lifeOption4">Bars use of a specific trait</label><br>
                <input type="checkbox" id="lifeOption5" name="lifeOptions" value="5">
                <label for="lifeOption5">Other</label>
            </div>
        </div>
        <div>
            <input type="radio" id="disabilityLayerToggle" name="layer" value="disability">
            <label for="disabilityLayerToggle">Disability</label>
            <div id="disabilityLayerOptions" class="checkbox-group" style="display: none;">
                <input type="checkbox" id="disabilityOption1" name="disabilityOptions" value="1">
                <label for="disabilityOption1">Requires informed consent</label><br>
                <input type="checkbox" id="disabilityOption2" name="disabilityOptions" value="2">
                <label for="disabilityOption2">Prohibits use of genetic info</label><br>
                <input type="checkbox" id="disabilityOption3" name="disabilityOptions" value="3">
                <label for="disabilityOption3">Allowed if actuarially justified</label><br>
                <input type="checkbox" id="disabilityOption4" name="disabilityOptions" value="4">
                <label for="disabilityOption4">Bars use of a specific trait</label><br>
                <input type="checkbox" id="disabilityOption5" name="disabilityOptions" value="5">
                <label for="disabilityOption5">Other</label>
            </div>
        </div>
        <div>
            <input type="radio" id="ltcLayerToggle" name="layer" value="ltc">
            <label for="ltcLayerToggle">LTC</label>
            <div id="ltcLayerOptions" class="checkbox-group" style="display: none;">
                <input type="checkbox" id="ltcOption1" name="ltcOptions" value="1">
                <label for="ltcOption1">Requires informed consent</label><br>
                <input type="checkbox" id="ltcOption2" name="ltcOptions" value="2">
                <label for="ltcOption2">Prohibits use of genetic info</label><br>
                <input type="checkbox" id="ltcOption3" name="ltcOptions" value="3">
                <label for="ltcOption3">Allowed if actuarially justified</label><br>
                <input type="checkbox" id="ltcOption4" name="ltcOptions" value="4">
                <label for="ltcOption4">Bars use of a specific trait</label><br>
                <input type="checkbox" id="ltcOption5" name="ltcOptions" value="5">
                <label for="ltcOption5">Other</label>
            </div>
        </div>
        <button id="filterButton">Filter</button>
        <button id="resetButton">Reset</button>
      </div>
      <h4 style="padding: 0 15px;">Read the State-by-State Laws:</h4>
      <div id="stateDetails" style="padding: 15px;"></div>
    </div>
  </div>

  <div id="legend" style="position: absolute; left: 20px; bottom: 20px; background-color: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);">
    <h4 style="margin-top: 0;">Total Categories Covered</h4>
    <div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: gray; margin-right: 5px;"></span> No Genetic Privacy Laws
      </div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: lightblue; margin-right: 5px;"></span> 1 of 3 Categories Covered
      </div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: blue; margin-right: 5px;"></span> 2 of 3 Categories Covered
      </div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: darkblue; margin-right: 5px;"></span> Life, Disability, and LTC Covered
      </div>
    </div>
  </div>

  <div id="filter-legend" style="position: absolute; left: 20px; bottom: 20px; background-color: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);">
    <h4 style="margin-top: 0;">Regulatory Coverage</h4>
    <div> 
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: gray; margin-right: 5px;"></span> Absent
      </div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: green; margin-right: 5px;"></span> Present
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div class="tooltip" id="tooltip"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://unpkg.com/topojson@3.0.2/dist/topojson.js"></script>

  <script>
    // Hide the filter-legend by default
    document.getElementById('filter-legend').style.display = 'none';

    // Hide all checkbox groups by default
    document.querySelectorAll('.checkbox-group').forEach(group => {
      group.style.display = 'none';
    });

    // Show the corresponding checkbox group when a radio button is clicked
    document.querySelectorAll('input[name="layer"]').forEach(radio => {
      radio.addEventListener('change', () => {
        document.querySelectorAll('.checkbox-group').forEach(group => {
          group.style.display = 'none';
        });

        const selectedLayer = radio.value;
        const checkboxGroup = document.getElementById(selectedLayer + 'LayerOptions');
        if (checkboxGroup) {
          checkboxGroup.style.display = 'block';
        }
      });
    });
/*
    // Initial setup: show the correct checkbox group based on the initially selected radio button
    document.addEventListener('DOMContentLoaded', () => {
      const selectedRadio = document.querySelector('input[name="layer"]:checked');
      if (selectedRadio) {
        const selectedGroup = document.querySelector(`#${selectedRadio.id}Options`);
        if (selectedGroup) {
          selectedGroup.style.display = 'block';
        }
      }
    });    
*/
    // Ensure radio buttons are unchecked on page reload
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('lifeLayerToggle').checked = false;
      document.getElementById('disabilityLayerToggle').checked = false;
      document.getElementById('ltcLayerToggle').checked = false;
    });

    // Ensure that all checkbox inputs are unchecked on page reload
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
    });

    // Event listener for the "Reset" button
    document.getElementById('resetButton').addEventListener('click', function() {
      // Show the legend
      document.getElementById('legend').style.display = 'block';
      // Hide the filter-legend
      document.getElementById('filter-legend').style.display = 'none';
      stateGroups.coverageGroup.style("visibility", "visible");
      stateGroups.filterGroup.style("visibility", "hidden");
      // Uncheck all checkboxes
      uncheckAllCheckboxes();
      // Repopulate sidebar with original data
      populateStateDetails(groupAndCountEntriesForStates(dnaPrivacy));
    }); 
    
    // Whenever a radio button is clicked, uncheck all checkboxes
    document.querySelectorAll('input[name="layer"]').forEach(radio => {
      radio.addEventListener('change', () => {
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
          checkbox.checked = false;
        });
      });
    });

    // Define the width and height for the SVG
    const width = window.innerWidth * 0.75;
    const height = window.innerHeight;

    // Create the SVG
    const svg = d3.select("#map")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    // Define the projection
    const projection = d3.geoAlbersUsa()
      .translate([width / 2, height / 2])
      .scale(1000);

    // Define the path
    const path = d3.geoPath(projection);

    // Create a tooltip
    const tooltip = d3.select("#tooltip");

    // Undefined variable to store the selected filter
    let selectedFilter;
    let selectedRowKey;

    // Load the data
    Promise.all([
      d3.csv("data/genetic-privacy.csv"),
      d3.json("data/states-10m.json")
    ]).then(makeMap).catch(error => console.error('Error loading data:', error));

    // Define an empty object to store the state groups
    let stateGroups = {};

    // Define the function to make the map
    function makeMap([dnaPrivacy, states]) {
      
      // Store the data in a global variable
      stateGroups = {
        coverageGroup: svg.append("g").attr("id", "coverageLayer"),
        filterGroup: svg.append("g").attr("id", "filterLayer"),
      };

      // Define the zoom behavior
      const zoom = d3.zoom().scaleExtent([0, 8]).on("zoom", zoomed);
      // Call the zoom behavior on the SVG
      svg.call(zoom);

      // Define the zoomed function
      function zoomed(event) {
        svg.selectAll("g").attr("transform", event.transform);
      }

      // Get the bounds of the map
      const bounds = path.bounds(topojson.feature(states, states.objects.states));
      // Calculate the initial scale
      const initialScale = Math.min(width / (bounds[1][0] - bounds[0][0]), height / (bounds[1][1] - bounds[0][1])) * 0.9;
      // Call the zoom behavior on the SVG
      svg.call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(initialScale).translate(-width / 2, -height / 2));

      // Event listener for the "Filter" button
      document.getElementById('filterButton').addEventListener('click', function() {
        // Hide the legend
        document.getElementById('legend').style.display = 'none';
        // Show the filter-legend
        document.getElementById('filter-legend').style.display = 'block';
        // Get the current filters
        const filters = {
          life: document.getElementById('lifeLayerToggle').checked,
          disability: document.getElementById('disabilityLayerToggle').checked,
          ltc: document.getElementById('ltcLayerToggle').checked
        };
        // Determine which filter is checked
        selectedFilter = Object.keys(filters).find(key => filters[key]);
        // If selectedFilter is 'ltc', change selectedRowKey to 'LTC'
        if (selectedFilter === 'ltc') {
          selectedRowKey = 'LTC';
        } else {
          // Create a capitalized version of the selected filter
          selectedRowKey = selectedFilter.charAt(0).toUpperCase() + selectedFilter.slice(1);
        };
        // Get the layer options filters using selectedFilter
        const subfilters = Object.fromEntries(
          Array.from(document.querySelectorAll('input[name="' + selectedFilter + 'Options"]'))
            .map(option => [option.value, option.checked])
        );
        // Apply the filters
        applyFilters(states, dnaPrivacy, filters, subfilters);
      });

      document.getElementById('resetButton').addEventListener('click', function() {
        stateGroups.coverageGroup.style("visibility", "visible");
        stateGroups.filterGroup.style("visibility", "hidden");
        // Repopulate sidebar with original data
        populateStateDetails(groupAndCountEntriesForStates(dnaPrivacy));
      });

      stateGroups.coverageGroup.style("visibility", "visible");
      stateGroups.filterGroup.style("visibility", "hidden");

      const groupedData = groupAndCountEntriesForStates(dnaPrivacy);

      // Draw initial map
      drawCoverageLayer(stateGroups.coverageGroup, states, groupedData);

      // Populate the sidebar with all state details
      populateStateDetails(groupedData);
    }

    function drawCoverageLayer(layerGroup, states, data) {

      // define the color scale
      const colorScale = d3.scaleLinear()
        .domain([0, 1, 2, 3])
        .range(["gray", "lightblue", "blue", "darkblue"]);

      layerGroup.selectAll("path")
        .data(topojson.feature(states, states.objects.states).features)
        .join("path")
        .attr("d", path)
        .attr("fill", d => {
          const stateData = data.find(state => state.name === d.properties.name);
          return stateData ? colorScale(stateData.count) : "gray";
        })
        .attr("stroke", "white")
        .attr("stroke-width", 0.5)
        .on("mouseover", function(event, d) {
          const stateName = d.properties.name;
          const stateData = data.find(state => state.name === stateName);
          const codeList = stateData ? stateData.codes.map(code => {
              let entries = [];
              if (code.disability) entries.push("Disability");
              if (code.life) entries.push("Life");
              if (code.ltc) entries.push("LTC");
              let entriesText = entries.length > 1 ? entries.join(', ') : entries[0] || 'N/A';
              return `<tr>
                          <td>${code.code}</td>
                          <td title="${entries.length ? entriesText : 'N/A'}">${entriesText}</td>
                      </tr>`;
          }).join('') : '<tr><td title="N/A">N/A</td></tr>';
          d3.select(this).classed("highlighted", true).raise();
          tooltip.transition().duration(0).style("opacity", .9);
          tooltip.html(`<div style="font-size: 16px; font-weight: bold;">${stateName}</div><table>${codeList}</table>`);
        })
        .on("mousemove", function(event) {
          tooltip.style("left", (event.pageX + 5) + "px")
            .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
          d3.select(this).classed("highlighted", false);
          tooltip.transition().duration(0).style("opacity", 0);
        });
    }

    let subcons = [];

    function drawCoverageLayerFiltered(layerGroup, states, filtered, all, subfilters) {

      const newFilters = {
        life: document.getElementById('lifeLayerToggle').checked,
        disability: document.getElementById('disabilityLayerToggle').checked,
        ltc: document.getElementById('ltcLayerToggle').checked
      };

      layerGroup.selectAll("path")
        .data(topojson.feature(states, states.objects.states).features)
        .join("path")
        .attr("d", path)
        .attr("fill", d => {
          const stateData = filtered.find(state => state.name === d.properties.name);
          return stateData ? "green" : "gray";
        })
        .attr("stroke", "white")
        .attr("stroke-width", 0.5)
        .on("mouseover", function(event, d) {
          const stateName = d.properties.name;
          const stateData = all.find(state => state.name === stateName);
          
          // if life in newFilters is true, then filter out all codes that are not life
          if (newFilters.life) {
            stateData.codes = stateData.codes.filter(code => code.life);
          } // otherwise, if disability in newFilters is true, then filter out all codes that are not disability
          else if (newFilters.disability) {
            stateData.codes = stateData.codes.filter(code => code.disability);
          } // otherwise, if ltc in newFilters is true, then filter out all codes that are not ltc
          else if (newFilters.ltc) {
            stateData.codes = stateData.codes.filter(code => code.ltc);
          }

          // if 'input[type="checkbox"]' is not checked, then show all codes
          if (!document.querySelector('input[type="checkbox"]').checked) {
            stateData.codes = stateData.codes;
          } else if (subfilters) {
            stateData.codes = stateData.codes.filter(code => {
              // Check if code[selectedFilter] includes any of the keys from subfilters that are true
              return Object.entries(subfilters).some(([key, value]) => {
                return value && code[selectedFilter] && code[selectedFilter].includes(key);
              });
            });
          }

          // clear the subcons array
          subcons.length = 0;

          // iterate through the codes and remove any when the combination of codes in the stateData.codes do not satisfy all subfilters
          stateData.codes.map(code => {
            subcons.push(code[selectedFilter]);
          });

          // from subfilters, return the keys that are true
          const subconsMatch = Object.keys(subfilters).filter(key => subfilters[key]);

          function arraysAreEquivalent(subcons, subconsMatch) {
            // Flatten subcons array if it contains comma-separated values
            const subconsSet = new Set(
              subcons.flatMap(element => element.split(","))
            );

            // Check if every element in subconsMatch is present in subconsSet
            return subconsMatch.every(element => subconsSet.has(element));
          }

          let codeList;

          // check if the subcons array and subconsMatch array are equivalent
          if (arraysAreEquivalent(subcons, subconsMatch)) {
            // set codeList to the filtered codes
            codeList = stateData.codes.map(code => 
                `<tr><td>${code.code ? code.code : 'N/A'}</td></tr>`
            ).join('');
          } else {
            codeList = '';
          }
       
          let newCodeList;

          if (codeList === '') {
            newCodeList = '<tr><td>N/A</td></tr>';
          } else {
            newCodeList = codeList; 
          };

          d3.select(this).classed("highlighted", true).raise();
          tooltip.transition().duration(0).style("opacity", .9);
          tooltip.html(`<div style="font-size: 16px; font-weight: bold;">${stateName}</div><table>${newCodeList}</table>`);
        })
        .on("mousemove", function(event) {
          tooltip.style("left", (event.pageX + 5) + "px")
            .style("top", (event.pageY - 28) + "px");
        })
        .on("mouseout", function() {
          d3.select(this).classed("highlighted", false);
          tooltip.transition().duration(0).style("opacity", 0);
        });
    }    

    function applyFilters(states, dnaPrivacy, filters, subfilters) {

      const filteredData = dnaPrivacy.filter(row => {
        return (!filters.life || row['Life']) ||
               (!filters.disability || row['Disability']) ||
               (!filters.ltc || row['LTC']);
      });

      const groupedData = groupAndCountEntriesForStates(filteredData);

      const filteredStateData = groupedData.filter(d => {
        const mainFiltersMatch = (filters.life ? d.life : true) &&
                                (filters.disability ? d.disability : true) &&
                                (filters.ltc ? d.ltc : true);

        // Check if all true values in subfilters are also true in filteredStateData
        const subfiltersMatch = Object.entries(subfilters).every(([key, value]) => {
          return value ? d[key] : true;
        });

        return mainFiltersMatch && subfiltersMatch;
      });

      stateGroups.coverageGroup.style("visibility", "hidden");
      stateGroups.filterGroup.style("visibility", "visible");

      drawCoverageLayerFiltered(stateGroups.filterGroup, states, filteredStateData, groupedData, subfilters);

      // Populate state details in the sidebar
      populateStateDetails(filteredStateData, filters, subfilters);
    }

    function populateStateDetails(stateData, filters, subfilters) {
      const stateDetailsContainer = document.getElementById('stateDetails');
      stateDetailsContainer.innerHTML = '';

      stateData.forEach(state => {
        const stateElement = document.createElement('div');
        stateElement.style.marginBottom = '10px';

        let filteredCodes = state.codes;

        // Apply filters if they are defined
        if (filters) {
          if (filters.life) {
            filteredCodes = filteredCodes.filter(code => code.life);
          } else if (filters.disability) {
            filteredCodes = filteredCodes.filter(code => code.disability);
          } else if (filters.ltc) {
            filteredCodes = filteredCodes.filter(code => code.ltc);
          }
        }


        // if 'input[type="checkbox"]' is not checked, then show all codes
        if (!document.querySelector('input[type="checkbox"]').checked) {
          filteredCodes = filteredCodes;
        } else if (subfilters) {
          filteredCodes = filteredCodes.filter(code => {
            // Check if any of the subfilters that return true are present in the code object
            return Object.entries(subfilters).some(([key, value]) => {
              return value && code[selectedFilter] && code[selectedFilter].includes(key);
            });
          });
        }        

        // define empty variables
        let stateName;
        let codeList;
        let codeTable;

        if (state.count != 0) {
          stateName = document.createElement('div');
          stateName.innerHTML = `<strong>${state.name}</strong>`;
          stateElement.appendChild(stateName);
          codeList = filteredCodes.map(code => `<tr><td><a href="${code.link}" target="_blank">${code.code}</a></td></tr>`).join('');
          codeTable = document.createElement('table');
          codeTable.innerHTML = codeList;
          stateElement.appendChild(codeTable);
          stateDetailsContainer.appendChild(stateElement);   
        } else {
          stateName = '';
          codeList = '';
          codeTable = '';
        }

      });
    }

    function groupAndCountEntriesForStates(data) {

      const stateDataMap = {};

      data.forEach(row => {
        const state = row.State;
        if (!stateDataMap[state]) {
          stateDataMap[state] = {
            name: state,
            life: false,
            disability: false,
            ltc: false,
            1: false,
            2: false,
            3: false,
            4: false,
            5: false,
            codes: []
          };
        }
        if (row.Life) stateDataMap[state].life = true;
        if (row.Disability) stateDataMap[state].disability = true;
        if (row.LTC) stateDataMap[state].ltc = true;

        // Check if row[selectedRowKey] exists and process subfilter selections
        if (row[selectedRowKey]) {
          // Split the selectedRowKey string into an array of values
          const selectedValues = row[selectedRowKey].split(',');
          
          // Iterate over each value and update corresponding object keys
          selectedValues.forEach(value => {
          
            stateDataMap[state][value] = true;
/*            
            // Check if the value is a valid key in the subfilters object
            if (subfilters[value]) {
              // Set the corresponding key in the stateDataMap to true
              stateDataMap[state][value] = true;
            }
*/
          });
        }

        stateDataMap[state].codes.push({ code: row.Code, link: row.Link, life: row.Life, disability: row.Disability, ltc: row.LTC});
      });

      const result = Object.values(stateDataMap).map(state => ({
        name: state.name,
        life: state.life,
        disability: state.disability,
        ltc: state.ltc,
        1: state[1],
        2: state[2],
        3: state[3],
        4: state[4],
        5: state[5],
        count: [state.life, state.disability, state.ltc].filter(Boolean).length,
        codes: state.codes
      })); 

      return result;

    }

    // Function to uncheck all checkboxes
    function uncheckAllCheckboxes() {
      // radio buttons
      document.getElementById('lifeLayerToggle').checked = false;
      document.getElementById('disabilityLayerToggle').checked = false;
      document.getElementById('ltcLayerToggle').checked = false;
      // subcategory check boxes
      document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
      // hide all checkbox groups
      document.querySelectorAll('.checkbox-group').forEach(group => {
        group.style.display = 'none';
      });
    }
  </script>
</body>

</html>