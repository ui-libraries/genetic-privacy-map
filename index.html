<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Genetic Privacy Laws in the US</title>
  <link href="https://fonts.googleapis.com/css?family=Montserrat" rel="stylesheet" type="text/css">
  <style>
    body,
    html {
      height: 100%;
      margin: 0;
      font-family: 'Montserrat', sans-serif;
    }

    #map {
      height: 100vh;
      width: calc(100vw - 350px);
      position: absolute;
      right: 0;
      top: 0;
      overflow: hidden;
    }

    .sidebar {
      width: 350px;
      height: calc(100vh - 190px);
      position: absolute;
      left: 0;
      top: 0;
      background: white;
      box-shadow: 2px 0 5px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      transition: width 0.3s ease;
      overflow: auto;
    }

    .sidebar-header {
      padding: 15px 0 15px 15px;
      background: #007BFF;
      color: white;
      text-align: left;
      font-size: 18px;
      font-weight: bold;
    }

    p {
      padding: 0 15px;
      font-size: 14px;
    }

    .layer-control {
      margin-top: 20px;
      padding-left: 15px;
    }

    .layer-control input {
      margin-right: 5px;
    }

    .layer-control button {
      margin: 10px;
      padding: 5px 10px;
      background-color: white;
      color: black;
      box-shadow: 2px 0 3px rgba(0, 0, 0, 0.5);
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    #compareButton {
      /* center the button */
      display: block;
      margin: 0 auto;
      padding: 5px 10px;
      background-color: white;
      color: black;
      box-shadow: 2px 0 3px rgba(0, 0, 0, 0.5);
      border: none;
      border-radius: 3px;
      cursor: pointer;      
    }

    .layer-control button:hover, #compareButton:hover {
      background-color: #f0f0f0;
      /* very light gray */
    }

    .checkbox-group {
      padding-left: 20px;
      margin-bottom: 10px;
    }

    .tooltip {
      position: absolute;
      text-align: left;
      padding: 5px;
      font: 12px sans-serif;
      background: lightsteelblue;
      border: 1px solid #ccc;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease-in-out;
    }

    .tooltip.visible {
      opacity: 1;
    }

    .highlighted {
      stroke: yellow;
      stroke-width: 2px;
    }

    table {
      border-collapse: collapse;
      width: 100%;
    }

    th,
    td {
      border: 1px solid black;
      padding: 8px;
      text-align: left;
    }

    .collapsible-header-overview, .collapsible-header-comparison {
      cursor: pointer;
    }

    .arrow-icon {
      display: inline-block;
      width: 20px;
      text-align: center;
    }

    .collapsible-content-overview, .collapsible-content-comparison {
      display: none;
    }

    /* Modal CSS */
    /* Style for the modal background */
    .modal {
        display: none;
        position: fixed;
        z-index: 1;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.5);
    }

    /* Style for the modal content box */
    .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding-top: 0px;
        padding-left: 20px;
        padding-bottom: 10px;
        padding-right: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 500px;
    }

    /* Style for the close button */
    .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
    }

    .close:hover,
    .close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
    }

    /* Style for the table inside the modal */
    #stateCompTable {
        width: 100%;
        border-collapse: collapse;
    }

    #typeHead, #firstStateHead, #secondStateHead, #Life, #Disability, #LTC, #firstStateLife, #secondStateLife, #firstStateDisability, #secondStateDisability, #fistStateLTC, #secondStateLTC {
        padding: 8px;
        text-align: left;
    }

    #typeHead, #firstStateHead, #secondStateHead {
        background-color: #f2f2f2;
    }    

    /* Style for the dropdown container */
    .dropdown-container {
        display: flex;
        justify-content: center;
        gap: 10px;
        margin-bottom: 20px;
    }    

  </style>
</head>

<body>

  <div class="sidebar" id="sidebar">
    <div class="sidebar-header">Genetic Privacy Laws in the USA</div>
    <div class="sidebar-content">
      <div class="collapsible-overview">
        <div class="collapsible-header-overview">
          <h4 style="padding: 0 15px;"><span class="arrow-icon">&#9658;</span> <!-- Right-facing arrow icon -->Overview</h4>
        </div>
        <div class="collapsible-content-overview">
          <p>To filter the map, select your desired combination of genetic privacy regulations and press the filter button. Press the reset button to return to the general coverage map.</p>
        </div>
      </div>
      <!-- STATE LAW COMPARISON START -->
      <div class="collapsible-comparison">
        <div class="collapsible-header-comparison">
          <h4 style="padding: 0 15px;"><span class="arrow-icon">&#9658;</span> <!-- Right-facing arrow icon -->Compare State Laws</h4>
        </div>
        <div class="collapsible-content-comparison">
          <p>To compare the legal coverage between two states, select the two states you want to compare from the dropdown menus. Click the "Compare" button and a table will display showing the key legal differences.</p>
          <!-- Dropdown menus for selecting states -->
          <div class="dropdown-container">
            <select id="firstStateDropdown">
                <!-- Populate with US states -->
            </select>
            <select id="secondStateDropdown">
                <!-- Populate with US states -->
            </select>
          </div>      
          <!-- Trigger/Open The Modal -->
          <button id="compareButton">Compare</button>
        </div>
      </div>

      <!-- The Modal -->
      <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>State Comparison</h2>
            <table id="stateCompTable">
                <thead>
                    <tr>
                        <th id="typeHead">Type</th>
                        <th id="firstStateHead">None selected</th>
                        <th id="secondStateHead">None selected</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td id="Life">Life</td>
                        <td id="firstStateLife"></td>
                        <td id="secondStateLife"></td>
                    </tr>
                    <tr>
                        <td id="Disability">Disability</td>
                        <td id="firstStateDisability"></td>
                        <td id="secondStateDisability"></td>
                    </tr>
                    <tr>
                        <td id="LTC">LTC</td>
                        <td id="firstStateLTC"></td>
                        <td id="secondStateLTC"></td>
                    </tr>
                </tbody>
            </table>
        </div>
      </div>
      <!-- STATE LAW COMPARISON END -->      
      <h4 style="padding: 0 15px;">Filter by Regulation Type:</h4>
      <div class="layer-control">
        <div>
          <input type="radio" id="lifeLayerToggle" name="layer" value="life">
          <label for="lifeLayerToggle">Life</label>
          <div id="lifeLayerOptions" class="checkbox-group" style="display: none;">
            <input type="checkbox" id="lifeOption1" name="lifeOptions" value="1">
            <label for="lifeOption1">Requires informed consent</label><br>
            <input type="checkbox" id="lifeOption2" name="lifeOptions" value="2">
            <label for="lifeOption2">Prohibits use of genetic info</label><br>
            <input type="checkbox" id="lifeOption3" name="lifeOptions" value="3">
            <label for="lifeOption3">Allowed if actuarially justified</label><br>
            <input type="checkbox" id="lifeOption4" name="lifeOptions" value="4">
            <label for="lifeOption4">Bars use of a specific trait</label><br>
            <input type="checkbox" id="lifeOption5" name="lifeOptions" value="5">
            <label for="lifeOption5">Other</label>
          </div>
        </div>
        <div>
          <input type="radio" id="disabilityLayerToggle" name="layer" value="disability">
          <label for="disabilityLayerToggle">Disability</label>
          <div id="disabilityLayerOptions" class="checkbox-group" style="display: none;">
            <input type="checkbox" id="disabilityOption1" name="disabilityOptions" value="1">
            <label for="disabilityOption1">Requires informed consent</label><br>
            <input type="checkbox" id="disabilityOption2" name="disabilityOptions" value="2">
            <label for="disabilityOption2">Prohibits use of genetic info</label><br>
            <input type="checkbox" id="disabilityOption3" name="disabilityOptions" value="3">
            <label for="disabilityOption3">Allowed if actuarially justified</label><br>
            <input type="checkbox" id="disabilityOption4" name="disabilityOptions" value="4">
            <label for="disabilityOption4">Bars use of a specific trait</label><br>
            <input type="checkbox" id="disabilityOption5" name="disabilityOptions" value="5">
            <label for="disabilityOption5">Other</label>
          </div>
        </div>
        <div>
          <input type="radio" id="ltcLayerToggle" name="layer" value="ltc">
          <label for="ltcLayerToggle">LTC</label>
          <div id="ltcLayerOptions" class="checkbox-group" style="display: none;">
            <input type="checkbox" id="ltcOption1" name="ltcOptions" value="1">
            <label for="ltcOption1">Requires informed consent</label><br>
            <input type="checkbox" id="ltcOption2" name="ltcOptions" value="2">
            <label for="ltcOption2">Prohibits use of genetic info</label><br>
            <input type="checkbox" id="ltcOption3" name="ltcOptions" value="3">
            <label for="ltcOption3">Allowed if actuarially justified</label><br>
            <input type="checkbox" id="ltcOption4" name="ltcOptions" value="4">
            <label for="ltcOption4">Bars use of a specific trait</label><br>
            <input type="checkbox" id="ltcOption5" name="ltcOptions" value="5">
            <label for="ltcOption5">Other</label>
          </div>
        </div>
        <button id="filterButton">Filter</button>
        <button id="resetButton">Reset</button>
      </div>

      <h4 style="padding: 0 15px;">Read the State-by-State Laws:</h4>
      <div id="stateDetails" style="padding: 15px;"></div>

      
    </div>
  </div>

  <div id="legend" style="position: absolute; left: 20px; bottom: 20px; background-color: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);">
    <h4 style="margin-top: 0;">Total Categories Covered</h4>
    <div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: gray; margin-right: 5px;"></span> No Genetic Privacy Laws
      </div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: lightblue; margin-right: 5px;"></span> 1 of 3 Categories Covered
      </div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: blue; margin-right: 5px;"></span> 2 of 3 Categories Covered
      </div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: darkblue; margin-right: 5px;"></span> Life, Disability, and LTC Covered
      </div>
    </div>
  </div>

  <div id="filter-legend" style="position: absolute; left: 20px; bottom: 20px; background-color: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);">
    <h4 style="margin-top: 0;">Regulatory Coverage</h4>
    <div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: gray; margin-right: 5px;"></span> Absent
      </div>
      <div style="display: flex; align-items: center;">
        <span style="display: inline-block; width: 20px; height: 20px; background-color: blue; margin-right: 5px;"></span> Present
      </div>
    </div>
  </div>

  <div id="map"></div>

  <div class="tooltip" id="tooltip"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.9.0/d3.min.js" integrity="sha512-vc58qvvBdrDR4etbxMdlTt4GBQk1qjvyORR2nrsPsFPyrs+/u5c3+1Ct6upOgdZoIl7eq6k3a1UPDSNAQi/32A==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://unpkg.com/topojson@3.0.2/dist/topojson.js"></script>

  <script>
    // Hide the filter-legend by default
    document.getElementById('filter-legend').style.display = 'none';

    // Hide all checkbox groups by default
    document.querySelectorAll('.checkbox-group').forEach(group => {
      group.style.display = 'none';
    });

    // Show the corresponding checkbox group when a radio button is clicked
    document.querySelectorAll('input[name="layer"]').forEach(radio => {
      radio.addEventListener('change', () => {
        document.querySelectorAll('.checkbox-group').forEach(group => {
          group.style.display = 'none';
        });

        const selectedLayer = radio.value;
        const checkboxGroup = document.getElementById(selectedLayer + 'LayerOptions');
        if (checkboxGroup) {
          checkboxGroup.style.display = 'block';
        }
      });
    });
    /*
        // Initial setup: show the correct checkbox group based on the initially selected radio button
        document.addEventListener('DOMContentLoaded', () => {
          const selectedRadio = document.querySelector('input[name="layer"]:checked');
          if (selectedRadio) {
            const selectedGroup = document.querySelector(`#${selectedRadio.id}Options`);
            if (selectedGroup) {
              selectedGroup.style.display = 'block';
            }
          }
        });    
    */
    // Ensure radio buttons are unchecked on page reload
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('lifeLayerToggle').checked = false;
      document.getElementById('disabilityLayerToggle').checked = false;
      document.getElementById('ltcLayerToggle').checked = false;
    });

    // Ensure that all checkbox inputs are unchecked on page reload
    document.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
    });

    // Event listener for the "Reset" button
    document.getElementById('resetButton').addEventListener('click', function() {
      // Show the legend
      document.getElementById('legend').style.display = 'block';
      // Hide the filter-legend
      document.getElementById('filter-legend').style.display = 'none';
      stateGroups.coverageGroup.style("visibility", "visible");
      stateGroups.filterGroup.style("visibility", "hidden");
      // Uncheck all checkboxes
      uncheckAllCheckboxes();
      // Repopulate sidebar with original data
      populateStateDetails(groupAndCountEntriesForStates(dnaPrivacy));
    });

    // Whenever a radio button is clicked, uncheck all checkboxes
    document.querySelectorAll('input[name="layer"]').forEach(radio => {
      radio.addEventListener('change', () => {
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
          checkbox.checked = false;
        });
      });
    });

    // Define the width and height for the SVG
    const width = window.innerWidth * 0.75;
    const height = window.innerHeight;

    // Create the SVG
    const svg = d3.select("#map")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    // Define the projection
    const projection = d3.geoAlbersUsa()
      .translate([width / 2, height / 2])
      .scale(1000);

    // Define the path
    const path = d3.geoPath(projection);

    // Create a tooltip
    const tooltip = d3.select("#tooltip");

    // Undefined variable to store the selected filter
    let selectedFilter;
    let selectedRowKey;

    // Load the data
    Promise.all([
      d3.csv("data/genetic-privacy.csv"),
      d3.json("data/states-10m.json")
    ]).then(makeMap).catch(error => console.error('Error loading data:', error));

    // Define an empty object to store the state groups
    let stateGroups = {};

    // Define the function to make the map
    function makeMap([dnaPrivacy, states]) {

      // Store the data in a global variable
      stateGroups = {
        coverageGroup: svg.append("g").attr("id", "coverageLayer"),
        filterGroup: svg.append("g").attr("id", "filterLayer"),
      };

      // Define the zoom behavior
      const zoom = d3.zoom().scaleExtent([0, 8]).on("zoom", zoomed);
      // Call the zoom behavior on the SVG
      svg.call(zoom);

      // Define the zoomed function
      function zoomed(event) {
        svg.selectAll("g").attr("transform", event.transform);
      }

      // Get the bounds of the map
      const bounds = path.bounds(topojson.feature(states, states.objects.states));
      // Calculate the initial scale
      const initialScale = Math.min(width / (bounds[1][0] - bounds[0][0]), height / (bounds[1][1] - bounds[0][1])) * 0.9;
      // Call the zoom behavior on the SVG
      svg.call(zoom.transform, d3.zoomIdentity.translate(width / 2, height / 2).scale(initialScale).translate(-width / 2, -height / 2));

      // Event listener for the "Filter" button
      document.getElementById('filterButton').addEventListener('click', function() {
        // Hide the legend
        document.getElementById('legend').style.display = 'none';
        // Show the filter-legend
        document.getElementById('filter-legend').style.display = 'block';
        // Get the current filters
        const filters = {
          life: document.getElementById('lifeLayerToggle').checked,
          disability: document.getElementById('disabilityLayerToggle').checked,
          ltc: document.getElementById('ltcLayerToggle').checked
        };
        // Determine which filter is checked
        selectedFilter = Object.keys(filters).find(key => filters[key]);
        // If selectedFilter is 'ltc', change selectedRowKey to 'LTC'
        if (selectedFilter === 'ltc') {
          selectedRowKey = 'LTC';
        } else {
          // Create a capitalized version of the selected filter
          selectedRowKey = selectedFilter.charAt(0).toUpperCase() + selectedFilter.slice(1);
        };
        // Get the layer options filters using selectedFilter
        const subfilters = Object.fromEntries(
          Array.from(document.querySelectorAll('input[name="' + selectedFilter + 'Options"]'))
          .map(option => [option.value, option.checked])
        );
        // Apply the filters
        applyFilters(states, dnaPrivacy, filters, subfilters);
      });

      document.getElementById('resetButton').addEventListener('click', function() {
        stateGroups.coverageGroup.style("visibility", "visible");
        stateGroups.filterGroup.style("visibility", "hidden");
        // Repopulate sidebar with original data
        populateStateDetails(groupAndCountEntriesForStates(dnaPrivacy));
      });

      stateGroups.coverageGroup.style("visibility", "visible");
      stateGroups.filterGroup.style("visibility", "hidden");

      const groupedData = groupAndCountEntriesForStates(dnaPrivacy);

      // Draw initial map
      drawCoverageLayer(stateGroups.coverageGroup, states, groupedData);

      // Populate the sidebar with all state details
      populateStateDetails(groupedData);

      // STATE LAW COMPARISON START
      // List of US states
      const compStates = [
          "None selected", "Alabama", "Alaska", "Arizona", "Arkansas", "California", "Colorado", "Connecticut", 
          "Delaware", "Florida", "Georgia", "Hawaii", "Idaho", "Illinois", "Indiana", "Iowa", 
          "Kansas", "Kentucky", "Louisiana", "Maine", "Maryland", "Massachusetts", "Michigan", 
          "Minnesota", "Mississippi", "Missouri", "Montana", "Nebraska", "Nevada", "New Hampshire", 
          "New Jersey", "New Mexico", "New York", "North Carolina", "North Dakota", "Ohio", 
          "Oklahoma", "Oregon", "Pennsylvania", "Rhode Island", "South Carolina", "South Dakota", 
          "Tennessee", "Texas", "Utah", "Vermont", "Virginia", "Washington", "West Virginia", 
          "Wisconsin", "Wyoming"
      ];

      // Populate the dropdown menus
      const firstStateDropdown = document.getElementById('firstStateDropdown');
      const secondStateDropdown = document.getElementById('secondStateDropdown');

      compStates.forEach(state => {
          const option1 = document.createElement('option');
          option1.value = state;
          option1.textContent = state;
          firstStateDropdown.appendChild(option1);

          const option2 = document.createElement('option');
          option2.value = state;
          option2.textContent = state;
          secondStateDropdown.appendChild(option2);
      });

      // Get the modal
      const modal = document.getElementById("myModal");

      // Get the button that opens the modal
      const btn = document.getElementById("compareButton");

      // Get the <span> element that closes the modal
      const span = document.getElementsByClassName("close")[0];

      // When the user clicks on <span> (x), close the modal
      span.onclick = function() {
          modal.style.display = "none";
      }

      // When the user clicks anywhere outside of the modal, close it
      window.onclick = function(event) {
          if (event.target == modal) {
              modal.style.display = "none";
          }
      }

      // Update the table headers when a state is selected
      firstStateDropdown.onchange = function() {
          document.getElementById('firstStateHead').textContent = firstStateDropdown.value;
      }

      secondStateDropdown.onchange = function() {
          // Prevent the user from selecting the same state in both dropdowns
          if (firstStateDropdown.value === secondStateDropdown.value) {
              alert('Please select two different states to compare.');
              secondStateDropdown.value = 'None selected';
          }
          document.getElementById('secondStateHead').textContent = secondStateDropdown.value;
      }

      // create an empty array to store the firstStateLife values
      const firstStateLife = [];
      // create an empty array to store the secondStateLife values
      const secondStateLife = [];
      // create an empty array to store the firstStateDisability values
      const firstStateDisability = [];
      // create an empty array to store the secondStateDisability values
      const secondStateDisability = [];
      // create an empty array to store the firstStateLTC values
      const firstStateLTC = [];
      // create an empty array to store the secondStateLTC values
      const secondStateLTC = [];

      // When the user clicks the button, open the modal
      btn.onclick = function() {
        modal.style.display = "block";

        // clear the arrays
        firstStateLife.length = 0;
        secondStateLife.length = 0;
        firstStateDisability.length = 0;
        secondStateDisability.length = 0;
        firstStateLTC.length = 0;
        secondStateLTC.length = 0;
          
        // run needed functions here

        // Iterate through each key in the first object of groupAndCountEntriesForComparison(dnaPrivacy, firstStateDropdown.value, secondStateDropdown.value)
        const firstState = groupAndCountEntriesForComparison(dnaPrivacy, firstStateDropdown.value, secondStateDropdown.value)[0][firstStateDropdown.value];
        const secondState = groupAndCountEntriesForComparison(dnaPrivacy, firstStateDropdown.value, secondStateDropdown.value)[1][secondStateDropdown.value];

        if (firstState.life1) {
          firstStateLife.push('Requires informed consent');
        } 
        if (firstState.life2) {
          firstStateLife.push('Prohibits use of genetic info');
        } 
        if (firstState.life3) {
          firstStateLife.push('Allowed if actuarially justified');
        } 
        if (firstState.life4) {
          firstStateLife.push('Bars use of a specific trait');
        } 
        if (firstState.life5) {
          firstStateLife.push('Other');
        } 
        // if none of the above conditions are met, push 'N/A' to the firstStateLife array
        if (!firstState.life1 && !firstState.life2 && !firstState.life3 && !firstState.life4 && !firstState.life5) {
          firstStateLife.push('N/A');
        }

        if (secondState.life1) {
          secondStateLife.push('Requires informed consent');
        }
        if (secondState.life2) {
          secondStateLife.push('Prohibits use of genetic info');
        }
        if (secondState.life3) {
          secondStateLife.push('Allowed if actuarially justified');
        }
        if (secondState.life4) {
          secondStateLife.push('Bars use of a specific trait');
        }
        if (secondState.life5) {
          secondStateLife.push('Other');
        }
        // if none of the above conditions are met, push 'N/A' to the secondStateLife array
        if (!secondState.life1 && !secondState.life2 && !secondState.life3 && !secondState.life4 && !secondState.life5) {
          secondStateLife.push('N/A');
        }

        if (firstState.disability1) {
          firstStateDisability.push('Requires informed consent');
        }
        if (firstState.disability2) {
          firstStateDisability.push('Prohibits use of genetic info');
        }
        if (firstState.disability3) {
          firstStateDisability.push('Allowed if actuarially justified');
        }
        if (firstState.disability4) {
          firstStateDisability.push('Bars use of a specific trait');
        }
        if (firstState.disability5) {
          firstStateDisability.push('Other');
        }
        // if none of the above conditions are met, push 'N/A' to the firstStateDisability array
        if (!firstState.disability1 && !firstState.disability2 && !firstState.disability3 && !firstState.disability4 && !firstState.disability5) {
          firstStateDisability.push('N/A');
        }

        if (secondState.disability1) {
          secondStateDisability.push('Requires informed consent');
        }
        if (secondState.disability2) {
          secondStateDisability.push('Prohibits use of genetic info');
        } 
        if (secondState.disability3) {
          secondStateDisability.push('Allowed if actuarially justified');
        }
        if (secondState.disability4) {
          secondStateDisability.push('Bars use of a specific trait');
        }
        if (secondState.disability5) {
          secondStateDisability.push('Other');
        }
        // if none of the above conditions are met, push 'N/A' to the secondStateDisability array
        if (!secondState.disability1 && !secondState.disability2 && !secondState.disability3 && !secondState.disability4 && !secondState.disability5) {
          secondStateDisability.push('N/A');
        }

        if (firstState.ltc1) {
          firstStateLTC.push('Requires informed consent');
        }
        if (firstState.ltc2) {
          firstStateLTC.push('Prohibits use of genetic info');
        }
        if (firstState.ltc3) {
          firstStateLTC.push('Allowed if actuarially justified');
        }
        if (firstState.ltc4) {
          firstStateLTC.push('Bars use of a specific trait');
        }
        if (firstState.ltc5) {
          firstStateLTC.push('Other');
        }
        // if none of the above conditions are met, push 'N/A' to the firstStateLTC array
        if (!firstState.ltc1 && !firstState.ltc2 && !firstState.ltc3 && !firstState.ltc4 && !firstState.ltc5) {
          firstStateLTC.push('N/A');
        }

        if (secondState.ltc1) {
          secondStateLTC.push('Requires informed consent');
        }
        if (secondState.ltc2) {
          secondStateLTC.push('Prohibits use of genetic info');
        }
        if (secondState.ltc3) {
          secondStateLTC.push('Allowed if actuarially justified');
        }
        if (secondState.ltc4) {
          secondStateLTC.push('Bars use of a specific trait');
        }
        if (secondState.ltc5) {
          secondStateLTC.push('Other');
        }
        // if none of the above conditions are met, push 'N/A' to the secondStateLTC array
        if (!secondState.ltc1 && !secondState.ltc2 && !secondState.ltc3 && !secondState.ltc4 && !secondState.ltc5) {
          secondStateLTC.push('N/A');
        }

        // Update the table with the values
        document.getElementById('firstStateLife').innerHTML = firstStateLife.join('<br>');
        document.getElementById('secondStateLife').innerHTML = secondStateLife.join('<br>');
        document.getElementById('firstStateDisability').innerHTML = firstStateDisability.join('<br>');
        document.getElementById('secondStateDisability').innerHTML = secondStateDisability.join('<br>');
        document.getElementById('firstStateLTC').innerHTML = firstStateLTC.join('<br>');
        document.getElementById('secondStateLTC').innerHTML = secondStateLTC.join('<br>');
      }    
      // STATE LAW COMPARISON END

    }

    function drawCoverageLayer(layerGroup, states, data) {

      // define the color scale
      const colorScale = d3.scaleLinear()
        .domain([0, 1, 2, 3])
        .range(["gray", "lightblue", "blue", "darkblue"]);

      layerGroup.selectAll("path")
        .data(topojson.feature(states, states.objects.states).features)
        .join("path")
        .attr("d", path)
        .attr("fill", d => {
          const stateData = data.find(state => state.name === d.properties.name);
          return stateData ? colorScale(stateData.count) : "gray";
        })
        .attr("stroke", "white")
        .attr("stroke-width", 0.5)
        .on("mouseover", function(event, d) {
          const stateName = d.properties.name;
          const stateData = data.find(state => state.name === stateName);
          const codeList = stateData ? stateData.codes.map(code => {
            let entries = [];
            if (code.disability) entries.push("Disability");
            if (code.life) entries.push("Life");
            if (code.ltc) entries.push("LTC");
            let entriesText = entries.length > 1 ? entries.join(', ') : entries[0] || 'N/A';
            return `<tr>
                    <td>${code.code || 'N/A'}</td>
                    <td title="${entries.length ? entriesText : 'N/A'}">${entriesText}</td>
                </tr>`;
          }).join('') : '<tr><td title="N/A">N/A</td><td title="N/A">N/A</td></tr>';

          // Add the table headers
          const tableHeaders = `<thead><tr><th>Laws</th><th>Type</th></tr></thead>`;

          d3.select(this).classed("highlighted", true).raise();

          const tooltipContent = `<div style="font-size: 16px; font-weight: bold;">${stateName}</div><table>${tableHeaders}<tbody>${codeList}</tbody></table>`;

          const x = event.pageX;
          const y = event.pageY;

          showTooltip(tooltipContent, x, y);
        })
        .on("mousemove", function(event) {
          const x = event.pageX;
          const y = event.pageY;

          const tooltip = document.querySelector('.tooltip');

          // Set initial position
          tooltip.style.left = `${x + 5}px`;
          tooltip.style.top = `${y - 28}px`;

          // Get the tooltip and map dimensions
          const tooltipRect = tooltip.getBoundingClientRect();
          const mapRect = document.querySelector('#map').getBoundingClientRect();

          // Adjust the position if the tooltip is too close to the right edge
          if (tooltipRect.right > mapRect.right) {
            tooltip.style.left = `${mapRect.right - tooltipRect.width}px`;
          }

          // Adjust the position if the tooltip is too close to the left edge
          if (tooltipRect.left < mapRect.left) {
            tooltip.style.left = `${mapRect.left}px`;
          }

          // Adjust the position if the tooltip is too close to the bottom edge
          if (tooltipRect.bottom > mapRect.bottom) {
            tooltip.style.top = `${mapRect.bottom - tooltipRect.height}px`;
          }

          // Adjust the position if the tooltip is too close to the top edge
          if (tooltipRect.top < mapRect.top) {
            tooltip.style.top = `${mapRect.top}px`;
          }
        })
        .on("mouseout", function() {
          d3.select(this).classed("highlighted", false);
          hideTooltip();
        });
    }

    let subcons = [];

    function drawCoverageLayerFiltered(layerGroup, states, filtered, all, subfilters) {

      const newFilters = {
        life: document.getElementById('lifeLayerToggle').checked,
        disability: document.getElementById('disabilityLayerToggle').checked,
        ltc: document.getElementById('ltcLayerToggle').checked
      };

      layerGroup.selectAll("path")
        .data(topojson.feature(states, states.objects.states).features)
        .join("path")
        .attr("d", path)
        .attr("fill", d => {
          const stateData = filtered.find(state => state.name === d.properties.name);
          return stateData ? "blue" : "gray";
        })
        .attr("stroke", "white")
        .attr("stroke-width", 0.5)
        .on("mouseover", function(event, d) {
          const stateName = d.properties.name;
          const stateData = all.find(state => state.name === stateName);

          // if life in newFilters is true, then filter out all codes that are not life
          if (newFilters.life) {
              stateData.codes = stateData.codes.filter(code => code.life);
          } // otherwise, if disability in newFilters is true, then filter out all codes that are not disability
          else if (newFilters.disability) {
              stateData.codes = stateData.codes.filter(code => code.disability);
          } // otherwise, if ltc in newFilters is true, then filter out all codes that are not ltc
          else if (newFilters.ltc) {
              stateData.codes = stateData.codes.filter(code => code.ltc);
          }

          // Check if any checkboxes are checked
          const checkboxes = document.querySelectorAll('input[type="checkbox"]');
          const anyChecked = Array.from(checkboxes).some(checkbox => checkbox.checked);  

          // if 'input[type="checkbox"]' is not checked, then show all codes
          if (!anyChecked) {
            stateData.codes = stateData.codes;
          } else {
            // Check subfilters and return the keys that are true
            const selectedBox = Object.keys(subfilters).filter(key => subfilters[key]);

            stateData.codes = stateData.codes.filter(code => {
              // Return the codes where code[selectedFilter] includes one of the values in selectedBox
              return selectedBox.some(value => code[selectedFilter].includes(value));
            });

          }

          // clear the subcons array
          subcons.length = 0;

          // iterate through the codes and push the selectedFilter values to the subcons array
          stateData.codes.map(code => {
              subcons.push(code[selectedFilter]);
          });

          // from subfilters, return the keys that are true
          const subconsMatch = Object.keys(subfilters).filter(key => subfilters[key]);

          function arraysAreEquivalent(subcons, subconsMatch) {
              // Flatten subcons array if it contains comma-separated values
              const subconsSet = new Set(
                  subcons.flatMap(element => element.split(","))
              );

              // Check if every element in subconsMatch is present in subconsSet
              return subconsMatch.every(element => subconsSet.has(element));
          }

          let codeList;

          // check if the subcons array and subconsMatch array are equivalent
          if (arraysAreEquivalent(subcons, subconsMatch)) {
            // Set codeList to the filtered codes
            codeList = stateData.codes.map(code => {
                let entries = [];
                if (code[selectedFilter].includes("1")) entries.push('<div style="white-space: nowrap;">1. <span style="text-indent: 1px; display: inline-block;">Requires informed consent</span></div>');
                if (code[selectedFilter].includes("2")) entries.push('<div style="white-space: nowrap;">2. <span style="text-indent: 1px; display: inline-block;">Prohibits use of genetic info</span></div>');
                if (code[selectedFilter].includes("3")) entries.push('<div style="white-space: nowrap;">3. <span style="text-indent: 1px; display: inline-block;">Allowed if actuarially justified</span></div>');
                if (code[selectedFilter].includes("4")) entries.push('<div style="white-space: nowrap;">4. <span style="text-indent: 1px; display: inline-block;">Bars use of a specific trait</span></div>');
                if (code[selectedFilter].includes("5")) entries.push('<div style="white-space: nowrap;">5. <span style="text-indent: 1px; display: inline-block;">Other</span></div>');
                // Combine entries into a single string
                let entriesText = entries.length > 0 ? entries.join('') : 'N/A';
                return `<tr><td>${code.code ? code.code : 'N/A'}</td><td>${entriesText ? entriesText : 'N/A'}</td></tr>`;
            }).join('');
          } else {
              codeList = '';
          }

          let newCodeList;

          // Update this condition to show "N/A" for both "Laws" and "Coverage" if no codes are returned
          if (codeList === '') {
              newCodeList = '<tr><td>N/A</td><td>N/A</td></tr>';
          } else {
              newCodeList = codeList;
          };

          const tooltipContent = `<div style="font-size: 16px; font-weight: bold;">${stateName}</div><table><thead><tr><th>Laws</th><th>Coverage</th></tr></thead><tbody>${newCodeList}</tbody></table>`;

          d3.select(this).classed("highlighted", true).raise();

          const x = event.pageX;
          const y = event.pageY;

          showTooltip(tooltipContent, x, y);
        })
        .on("mousemove", function(event) {
          const x = event.pageX;
          const y = event.pageY;

          const tooltip = document.querySelector('.tooltip');

          // Set initial position
          tooltip.style.left = `${x + 5}px`;
          tooltip.style.top = `${y - 28}px`;

          // Get the tooltip and map dimensions
          const tooltipRect = tooltip.getBoundingClientRect();
          const mapRect = document.querySelector('#map').getBoundingClientRect();

          // Adjust the position if the tooltip is too close to the right edge
          if (tooltipRect.right > mapRect.right) {
            tooltip.style.left = `${mapRect.right - tooltipRect.width}px`;
          }

          // Adjust the position if the tooltip is too close to the left edge
          if (tooltipRect.left < mapRect.left) {
            tooltip.style.left = `${mapRect.left}px`;
          }

          // Adjust the position if the tooltip is too close to the bottom edge
          if (tooltipRect.bottom > mapRect.bottom) {
            tooltip.style.top = `${mapRect.bottom - tooltipRect.height}px`;
          }

          // Adjust the position if the tooltip is too close to the top edge
          if (tooltipRect.top < mapRect.top) {
            tooltip.style.top = `${mapRect.top}px`;
          }
        })
        .on("mouseout", function() {
          d3.select(this).classed("highlighted", false);
          hideTooltip();
        });
    }

    function applyFilters(states, dnaPrivacy, filters, subfilters) {

      const filteredData = dnaPrivacy.filter(row => {
        return (!filters.life || row['Life']) ||
          (!filters.disability || row['Disability']) ||
          (!filters.ltc || row['LTC']);
      });

      const groupedData = groupAndCountEntriesForStates(filteredData);

      const filteredStateData = groupedData.filter(d => {
        const mainFiltersMatch = (filters.life ? d.life : true) &&
          (filters.disability ? d.disability : true) &&
          (filters.ltc ? d.ltc : true);

        // Check if all true values in subfilters are also true in filteredStateData
        const subfiltersMatch = Object.entries(subfilters).every(([key, value]) => {
          return value ? d[key] : true;
        });

        return mainFiltersMatch && subfiltersMatch;
      });

      stateGroups.coverageGroup.style("visibility", "hidden");
      stateGroups.filterGroup.style("visibility", "visible");

      drawCoverageLayerFiltered(stateGroups.filterGroup, states, filteredStateData, groupedData, subfilters);

      // Populate state details in the sidebar
      populateStateDetails(filteredStateData, filters, subfilters);
    }

    function populateStateDetails(stateData, filters, subfilters) {
      const stateDetailsContainer = document.getElementById('stateDetails');
      stateDetailsContainer.innerHTML = '';

      stateData.forEach(state => {
        const stateElement = document.createElement('div');
        stateElement.style.marginBottom = '10px';

        let filteredCodes = state.codes;

        // Apply filters if they are defined
        if (filters) {
          if (filters.life) {
            filteredCodes = filteredCodes.filter(code => code.life);
          } else if (filters.disability) {
            filteredCodes = filteredCodes.filter(code => code.disability);
          } else if (filters.ltc) {
            filteredCodes = filteredCodes.filter(code => code.ltc);
          }
        }

        // Check if any checkboxes are checked
        const checkboxes = document.querySelectorAll('input[type="checkbox"]');
        const anyChecked = Array.from(checkboxes).some(checkbox => checkbox.checked);        

        // if 'input[type="checkbox"]' is not checked, then show all codes
        if (!anyChecked) {
          filteredCodes = filteredCodes;
        } else  {
          // Check subfilters and return the keys that are true
          const selectedBox = Object.keys(subfilters).filter(key => subfilters[key]);
          // Filter the codes based on the selectedBox values
          filteredCodes = filteredCodes.filter(code => {
            // Return the codes where code[selectedFilter] includes one of the values in selectedBox
            return selectedBox.some(value => code[selectedFilter].includes(value));
          });
        }

        // define empty variables
        let stateName;
        let codeList;
        let codeTable;

        if (state.count != 0) {
          stateName = document.createElement('div');
          stateName.innerHTML = `<strong>${state.name}</strong>`;
          stateElement.appendChild(stateName);
          // If a radio button is selected
          if (filters) { 
            codeList = filteredCodes.map(code => {
              let entries = [];
              if (code[selectedFilter].includes("1")) entries.push('<li>Requires informed consent</li>');
              if (code[selectedFilter].includes("2")) entries.push('<li>Prohibits use of genetic info</li>');
              if (code[selectedFilter].includes("3")) entries.push('<li>Allowed if actuarially justified</li>');
              if (code[selectedFilter].includes("4")) entries.push('<li>Bars use of a specific trait</li>');
              if (code[selectedFilter].includes("5")) entries.push('<li>Other</li>');
              // Combine entries into a single string
              let entriesText = entries.length > 0 ? entries.join('<br>') : '<li>N/A</li>';
              return `<tr><td><a href="${code.link}" target="_blank">${code.code}</a></td><td title="${entries.length ? entriesText : 'N/A'}"><ul>${entriesText}</ul></td></tr>`;
            }).join('');
          } else {
            codeList = filteredCodes.map(code => {
              let entries = [];
              if (code.life) entries.push("Life");
              if (code.disability) entries.push("Disability");
              if (code.ltc) entries.push("LTC");
              let entriesText = entries.length > 1 ? entries.join(', ') : entries[0] || 'N/A';
              return `<tr><td><a href="${code.link}" target="_blank">${code.code}</a></td><td title="${entries.length ? entriesText : 'N/A'}">${entriesText}</td></tr>`;
            }).join('');
          }
          codeTable = document.createElement('table');
          codeTable.innerHTML = codeList;
          stateElement.appendChild(codeTable);
          stateDetailsContainer.appendChild(stateElement);
        } else {
          stateName = '';
          codeList = '';
          codeTable = '';
        }

      });
    }

    function groupAndCountEntriesForComparison(data, selection1, selection2) {

      const selection1DataMap = {};
      const selection2DataMap = {};

      data.forEach(row => {
        const state = row.State;
        if (state === selection1) {
          if (!selection1DataMap[state]) {
            selection1DataMap[state] = {
              name: state,
              life: false,
              life1: false,
              life2: false,
              life3: false,
              life4: false,
              life5: false,
              disability: false,
              disability1: false,
              disability2: false,
              disability3: false,
              disability4: false,
              disability5: false,
              ltc: false,
              ltc1: false,
              ltc2: false,
              ltc3: false,
              ltc4: false,
              ltc5: false,
              codes: []
            };
          }
          if (row.Life) selection1DataMap[state].life = true;
          if (row.Disability) selection1DataMap[state].disability = true;
          if (row.LTC) selection1DataMap[state].ltc = true;

          // Process subfilter selections
          // Check if row.Life exists and process subfilter selections
          if (row.Life) {
            // Split the string into an array of values
            const lifeSubValues = row['Life'].split(',');
            // Iterate over each value and...
            lifeSubValues.forEach(value => {
              // ...update corresponding object keys
              selection1DataMap[state]['life' + value] = true;
            });
          }
          // Check if row.Disability exists and process subfilter selections
          if (row.Disability) {
            // Split the string into an array of values
            const disabilitySubValues = row['Disability'].split(',');
            // Iterate over each value and...
            disabilitySubValues.forEach(value => {
              // ...update corresponding object keys
              selection1DataMap[state]['disability' + value] = true;
            });
          }
          // Check if row.LTC exists and process subfilter selections
          if (row.LTC) {
            // Split the string into an array of values
            const ltcSubValues = row['LTC'].split(',');
            // Iterate over each value and...
            ltcSubValues.forEach(value => {
              // ...update corresponding object keys
              selection1DataMap[state]['ltc' + value] = true;
            });
          }
          // Push the code object to the codes array
          selection1DataMap[state].codes.push({
            code: row.Code,
            link: row.Link,
            life: row.Life,
            disability: row.Disability,
            ltc: row.LTC
          });
        } else if (state === selection2) {
          if (!selection2DataMap[state]) {
            selection2DataMap[state] = {
              name: state,
              life: false,
              life1: false,
              life2: false,
              life3: false,
              life4: false,
              life5: false,
              disability: false,
              disability1: false,
              disability2: false,
              disability3: false,
              disability4: false,
              disability5: false,
              ltc: false,
              ltc1: false,
              ltc2: false,
              ltc3: false,
              ltc4: false,
              ltc5: false,
              codes: []
            };
          }
          if (row.Life) selection2DataMap[state].life = true;
          if (row.Disability) selection2DataMap[state].disability = true;
          if (row.LTC) selection2DataMap[state].ltc = true;

          // Process subfilter selections
          // Check if row.Life exists and process subfilter selections
          if (row.Life) {
            // Split the string into an array of values
            const lifeSubValues = row['Life'].split(',');
            // Iterate over each value and...
            lifeSubValues.forEach(value => {
              // ...update corresponding object keys
              selection2DataMap[state]['life' + value] = true;
            });
          }
          // Check if row.Disability exists and process subfilter selections
          if (row.Disability) {
            // Split the string into an array of values
            const disabilitySubValues = row['Disability'].split(',');
            // Iterate over each value and...
            disabilitySubValues.forEach(value => {
              // ...update corresponding object keys
              selection2DataMap[state]['disability' + value] = true;
            });
          }
          // Check if row.LTC exists and process subfilter selections
          if (row.LTC) {
            // Split the string into an array of values
            const ltcSubValues = row['LTC'].split(',');
            // Iterate over each value and...
            ltcSubValues.forEach(value => {
              // ...update corresponding object keys
              selection2DataMap[state]['ltc' + value] = true;
            });
          }

          selection2DataMap[state].codes.push({
            code: row.Code,
            link: row.Link,
            life: row.Life,
            disability: row.Disability,
            ltc: row.LTC
          });    
          
        }
      });

      // return selection1DataMap and selection2DataMap
      return [selection1DataMap, selection2DataMap];

    }

    function groupAndCountEntriesForStates(data) {

      const stateDataMap = {};

      data.forEach(row => {
        const state = row.State;
        if (!stateDataMap[state]) {
          stateDataMap[state] = {
            name: state,
            life: false,
            disability: false,
            ltc: false,
            1: false,
            2: false,
            3: false,
            4: false,
            5: false,
            codes: []
          };
        }
        if (row.Life) stateDataMap[state].life = true;
        if (row.Disability) stateDataMap[state].disability = true;
        if (row.LTC) stateDataMap[state].ltc = true;

        // Check if row[selectedRowKey] exists and process subfilter selections
        if (row[selectedRowKey]) {
          // Split the selectedRowKey string into an array of values
          const selectedValues = row[selectedRowKey].split(',');

          // Iterate over each value and update corresponding object keys
          selectedValues.forEach(value => {
            stateDataMap[state][value] = true;
          });
        }

        stateDataMap[state].codes.push({
          code: row.Code,
          link: row.Link,
          life: row.Life,
          disability: row.Disability,
          ltc: row.LTC
        });
      });

      const result = Object.values(stateDataMap).map(state => ({
        name: state.name,
        life: state.life,
        disability: state.disability,
        ltc: state.ltc,
        1: state[1],
        2: state[2],
        3: state[3],
        4: state[4],
        5: state[5],
        count: [state.life, state.disability, state.ltc].filter(Boolean).length,
        codes: state.codes
      }));

      return result;

    }

    // Function to uncheck all checkboxes
    function uncheckAllCheckboxes() {
      // radio buttons
      document.getElementById('lifeLayerToggle').checked = false;
      document.getElementById('disabilityLayerToggle').checked = false;
      document.getElementById('ltcLayerToggle').checked = false;
      // subcategory check boxes
      document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
        checkbox.checked = false;
      });
      // hide all checkbox groups
      document.querySelectorAll('.checkbox-group').forEach(group => {
        group.style.display = 'none';
      });
    }

    // Functions to handle tooltip positioning
    function showTooltip(htmlContent, x, y) {
      const tooltip = document.querySelector('.tooltip');
      tooltip.innerHTML = htmlContent;

      // Set initial position
      tooltip.style.left = `${x}px`;
      tooltip.style.top = `${y}px`;

      // Get the tooltip and map dimensions
      const tooltipRect = tooltip.getBoundingClientRect();
      const mapRect = document.querySelector('#map').getBoundingClientRect();

      // Adjust the position if the tooltip is too close to the right edge
      if (tooltipRect.right > mapRect.right) {
        tooltip.style.left = `${mapRect.right - tooltipRect.width}px`;
      }

      // Adjust the position if the tooltip is too close to the left edge
      if (tooltipRect.left < mapRect.left) {
        tooltip.style.left = `${mapRect.left}px`;
      }

      // Adjust the position if the tooltip is too close to the bottom edge
      if (tooltipRect.bottom > mapRect.bottom) {
        tooltip.style.top = `${mapRect.bottom - tooltipRect.height}px`;
      }

      // Adjust the position if the tooltip is too close to the top edge
      if (tooltipRect.top < mapRect.top) {
        tooltip.style.top = `${mapRect.top}px`;
      }

      // Show the tooltip
      tooltip.classList.add('visible');
    }

    function hideTooltip() {
      const tooltip = document.querySelector('.tooltip');
      tooltip.classList.remove('visible');
    }

    // Collapsible content instructions
    // Get the collapsible section, header, and button
    const collapsibleSectionOverview = document.querySelector('.collapsible-overview');
    const collapsibleSectionComparison = document.querySelector('.collapsible-comparison');
    const collapsibleHeaderOverview = document.querySelector('.collapsible-header-overview');
    const collapsibleHeaderComparison = document.querySelector('.collapsible-header-comparison');
    const compareButton = document.getElementById('compareButton');

    // Toggle the visibility of the collapsible content when the header is clicked
    collapsibleHeaderOverview.addEventListener('click', function() {
      const content = collapsibleSectionOverview.querySelector('.collapsible-content-overview');
      const arrowIcon = collapsibleHeaderOverview.querySelector('.arrow-icon');
      if (content.style.display === 'block') {
        content.style.display = 'none';
        arrowIcon.innerHTML = '&#9658;'; // Right-facing arrow
      } else {
        content.style.display = 'block';
        arrowIcon.innerHTML = '&#9660;'; // Down-facing arrow
      }
    });

    // Toggle the visibility of the collapsible content when the header is clicked
    collapsibleHeaderComparison.addEventListener('click', function() {
      const content = collapsibleSectionComparison.querySelector('.collapsible-content-comparison');
      const arrowIcon = collapsibleHeaderComparison.querySelector('.arrow-icon');
      if (content.style.display === 'block') {
        content.style.display = 'none';
        arrowIcon.innerHTML = '&#9658;'; // Right-facing arrow
      } else {
        content.style.display = 'block';
        arrowIcon.innerHTML = '&#9660;'; // Down-facing arrow
      }
    });

    // Show the content if the button is clicked (for demonstration purposes)
    compareButton.addEventListener('click', function() {
      const content = collapsibleSectionComparison.querySelector('.collapsible-content-comparison');
      const arrowIcon = collapsibleHeaderComparison.querySelector('.arrow-icon');
      content.style.display = 'block';
      arrowIcon.innerHTML = '&#9660;'; // Down-facing arrow
    });


  </script>
</body>

</html>